# -*- coding: utf-8 -*-
"""Entregable 3_TINYML

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CC0cfsZwbXDVETRwvIs5ceE8FNupNAYD

##CONVERSIÓN DE FORMATO ACEPTABLE EN EDGE IMPULSE
"""

import os

# List files in the current directory
files = os.listdir('.')
print(files)

import json
from datetime import datetime
import hashlib
import hmac

def convert_format(original_data):
    # Extraer los puntos
    stroke_points = original_data[0]['strokePoints']

    # Inicializar los valores para los sensores
    values = []
    for point in stroke_points:
        x = point['x']
        y = point['y']
        # Aquí podrías ajustar cómo conviertes x e y a los diferentes sensores
        # En este caso, asumimos solo 2 sensores de ejemplo, accX y accY
        values.append([x, y, 0, 0, 0, 0, 0, 0, 0])

    # Crear el payload en el formato requerido
    payload = {
        "device_name": "computer_m0zpyxqd",
        "device_type": "MOBILE_CLIENT",
        "interval_ms": 16,
        "sensors": [
            {"name": "accX", "units": "m/s2"},
            {"name": "accY", "units": "m/s2"},
            {"name": "accZ", "units": "m/s2"},
            {"name": "gyroX", "units": "deg/s"},
            {"name": "gyroY", "units": "deg/s"},
            {"name": "gyroZ", "units": "deg/s"},
            {"name": "yaw", "units": "deg"},
            {"name": "pitch", "units": "deg"},
            {"name": "roll", "units": "deg"}
        ],
        "values": values
    }

    # Crear el protected
    protected = {
        "ver": "v1",
        "alg": "HS256",
        "iat": int(datetime.utcnow().timestamp())
    }

    # Crear la firma (este es solo un ejemplo, necesitarás una clave secreta real)
    secret = b"your_secret_key"
    data = json.dumps(protected, sort_keys=True).encode()
    signature = hmac.new(secret, data, hashlib.sha256).hexdigest()

    # Crear el JSON final
    result = {
        "protected": protected,
        "signature": signature,
        "payload": payload
    }

    return json.dumps(result, indent=4)

# Ejemplo de uso
original_data = [
    {
        "index": 0,
        "strokePoints": [
            {"x": -0.1328125, "y": 0},
            {"x": -0.1328125, "y": 0.0078125},
            # ... Agrega aquí el resto de tus puntos
        ],
        "label": "1"
    }
]

# Convertir y mostrar el resultado
converted_data = convert_format(original_data)
print(converted_data)

"""###SEPARACIÓN POR INDEX"""

import json
from datetime import datetime
import hashlib
import hmac

def convert_format(original_data):
    # Inicializar los valores para los sensores
    values = []

    for item in original_data:
        index = item['index']
        stroke_points = item['strokePoints']

        # Convertir el índice a un valor numérico específico (aquí lo incrementamos por 1)
        index_value = index + 1

        for point in stroke_points:
            x = point['x']
            y = point['y']
            # Agregamos el índice como un valor adicional
            # Aquí asumimos que solo usaremos los primeros 2 sensores para x e y y los demás son cero
            values.append([x, y, 0, 0, 0, 0, 0, 0, index_value])

    # Crear el payload en el formato requerido
    payload = {
        "device_name": "computer_m0zpyxqd",
        "device_type": "MOBILE_CLIENT",
        "interval_ms": 16,
        "sensors": [
            {"name": "accX", "units": "m/s2"},
            {"name": "accY", "units": "m/s2"},
            {"name": "accZ", "units": "m/s2"},
            {"name": "gyroX", "units": "deg/s"},
            {"name": "gyroY", "units": "deg/s"},
            {"name": "gyroZ", "units": "deg/s"},
            {"name": "yaw", "units": "deg"},
            {"name": "pitch", "units": "deg"},
            {"name": "roll", "units": "deg"}
        ],
        "values": values
    }

    # Crear el protected
    protected = {
        "ver": "v1",
        "alg": "HS256",
        "iat": int(datetime.utcnow().timestamp())
    }

    # Crear la firma (este es solo un ejemplo, necesitarás una clave secreta real)
    secret = b"your_secret_key"
    data = json.dumps(protected, sort_keys=True).encode()
    signature = hmac.new(secret, data, hashlib.sha256).hexdigest()

    # Crear el JSON final
    result = {
        "protected": protected,
        "signature": signature,
        "payload": payload
    }

    return json.dumps(result, indent=4)

# Ejemplo de uso
original_data = [
    {
        "index": 0,
        "strokePoints": [
            {"x": -0.1328125, "y": 0},
            {"x": -0.1328125, "y": 0.0078125}
            # ... Agrega aquí el resto de tus puntos
        ],
        "label": "1"
    },
    {
        "index": 1,
        "strokePoints": [
            {"x": -0.2, "y": 0.1},
            {"x": -0.2, "y": 0.15}
            # ... Agrega aquí el resto de tus puntos
        ],
        "label": "2"
    }
]

# Convertir y mostrar el resultado
converted_data = convert_format(original_data)
print(converted_data)

"""###GUARDAR LOS CAMBIOS EN LA NUEVA CARPETA: "Archivos nuevos"
"""

import json
import os
from datetime import datetime
import hashlib
import hmac

def convert_format(original_data):
    # Verificar si original_data contiene la clave 'strokes'
    if isinstance(original_data, dict) and 'strokes' in original_data:
        original_data = original_data['strokes']  # Extraer la lista de 'strokes'
    elif not isinstance(original_data, list):
        raise ValueError("Los datos originales deben ser una lista de diccionarios.")

    # Inicializar los valores para los sensores
    values = []

    for item in original_data:
        if not isinstance(item, dict) or 'strokePoints' not in item or 'index' not in item:
            raise ValueError("Cada ítem en los datos originales debe ser un diccionario con 'strokePoints' y 'index'.")

        index = item['index']
        stroke_points = item['strokePoints']

        # Convertir el índice a un valor numérico específico (aquí lo incrementamos por 1)
        index_value = index + 1

        for point in stroke_points:
            x = point['x']
            y = point['y']
            # Agregamos el índice como un valor adicional
            values.append([x, y, 0, 0, 0, 0, 0, 0, index_value])

    # Crear el payload en el formato requerido
    payload = {
        "device_name": "computer_m0zpyxqd",
        "device_type": "MOBILE_CLIENT",
        "interval_ms": 16,
        "sensors": [
            {"name": "accX", "units": "m/s2"},
            {"name": "accY", "units": "m/s2"},
            {"name": "accZ", "units": "m/s2"},
            {"name": "gyroX", "units": "deg/s"},
            {"name": "gyroY", "units": "deg/s"},
            {"name": "gyroZ", "units": "deg/s"},
            {"name": "yaw", "units": "deg"},
            {"name": "pitch", "units": "deg"},
            {"name": "roll", "units": "deg"}
        ],
        "values": values
    }

    # Crear el protected
    protected = {
        "ver": "v1",
        "alg": "HS256",
        "iat": int(datetime.utcnow().timestamp())
    }

    # Crear la firma (este es solo un ejemplo, necesitarás una clave secreta real)
    secret = b"your_secret_key"
    data = json.dumps(protected, sort_keys=True).encode()
    signature = hmac.new(secret, data, hashlib.sha256).hexdigest()

    # Crear el JSON final
    result = {
        "protected": protected,
        "signature": signature,
        "payload": payload
    }

    return json.dumps(result, indent=4)

def process_and_save_files(input_files, output_folder):
    # Verifica si la carpeta de salida existe, si no, la crea
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    for filename in input_files:
        input_file_path = f'/content/{filename}'
        print(f"Procesando el archivo: {filename}")

        # Leer los datos del archivo JSON
        try:
            with open(input_file_path, 'r') as file:
                original_data = json.load(file)
                print(f"Datos leídos del archivo {filename}: {original_data}")
        except json.JSONDecodeError as e:
            print(f"Error al leer el archivo {filename}: {e}")
            continue  # Salta al siguiente archivo

        # Verifica si los datos cargados contienen la clave 'strokes'
        if isinstance(original_data, dict) and 'strokes' in original_data:
            original_data = original_data['strokes']  # Extraer la lista de 'strokes'
        elif not isinstance(original_data, list):
            print(f"Los datos en {filename} no son una lista o no contienen 'strokes'.")
            continue  # Salta al siguiente archivo

        # Convertir los datos
        try:
            converted_data = convert_format(original_data)
            print(f"Datos convertidos del archivo {filename}: {converted_data}")
        except ValueError as e:
            print(f"Error al convertir el archivo {filename}: {e}")
            continue  # Salta al siguiente archivo

        # Guardar el archivo convertido en la carpeta de salida
        output_file_path = os.path.join(output_folder, filename)
        with open(output_file_path, 'w') as file:
            file.write(converted_data)
            print(f"Archivo convertido guardado en {output_file_path}")

# Define los archivos de entrada y la carpeta de salida
input_files = ['1.1.1.json']
output_folder = '/content/Archivos nuevos'

# Procesar y guardar los archivos
process_and_save_files(input_files, output_folder)
